name: Application Deployment

on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
      - 'k8s/**'
      - '.github/workflows/applications.yml'
  pull_request:
    branches: [main]
    paths:
      - 'apps/**'
      - 'k8s/**'
      - '.github/workflows/applications.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  KUBECTL_VERSION: 'v1.31.0'

jobs:
  validate-manifests:
    name: Validate K8s Manifests
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Validate Kubernetes manifests
      run: |
        # Validate YAML syntax for Kubernetes manifests (supports multi-document files)
        cat > /tmp/validate_yaml.py << 'EOF'
        import yaml
        import sys
        
        file_path = sys.argv[1]
        try:
            with open(file_path, 'r') as f:
                docs = list(yaml.safe_load_all(f))
                print(f"✓ Valid YAML syntax - {len(docs)} document(s)")
        except yaml.YAMLError as e:
            print(f"✗ Invalid YAML: {e}")
            sys.exit(1)
        EOF
        
        find k8s apps -name "*.yaml" -o -name "*.yml" | while read file; do
          echo "Validating: $file"
          python3 /tmp/validate_yaml.py "$file" || exit 1
        done

  deploy-apps:
    name: Deploy Applications
    needs: validate-manifests
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: ${{ env.KUBECTL_VERSION }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: 'latest'
    
    - name: Configure Kubeconfig
      env:
        KUBECONFIG_BASE64: ${{ secrets.KUBECONFIG_BASE64 }}
      run: |
        mkdir -p ~/.kube
        echo "$KUBECONFIG_BASE64" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config
        # Validate kubeconfig format
        kubectl config view --minify
        echo "Kubeconfig configured successfully"
        kubectl get nodes
    
    - name: Deploy Core Services
      run: |
        echo "Deploying core infrastructure services..."
        
        # Deploy StackGres Operator
        if ! kubectl get namespace stackgres &>/dev/null; then
          echo "Installing StackGres operator..."
          kubectl create namespace stackgres
          
          # Add Helm repository with retry
          for i in {1..3}; do
            if helm repo add stackgres https://stackgres.io/downloads/stackgres-k8s/stackgres/helm; then
              break
            fi
            echo "Retry $i: Adding StackGres Helm repo..."
            sleep 5
          done
          
          helm repo update
          
          # Install operator
          helm install stackgres stackgres/stackgres-operator \
            --namespace stackgres \
            --set grafana.autoEmbed=true \
            --set-string adminui.service.type=ClusterIP \
            --wait --timeout 3m
          
          # Wait for CRDs to be available
          echo "Waiting for StackGres CRDs to be installed..."
          for i in {1..30}; do
            if kubectl get crd sgclusters.stackgres.io &>/dev/null; then
              echo "StackGres CRDs are ready"
              break
            fi
            echo "Waiting for CRDs... ($i/30)"
            sleep 2
          done
        else
          echo "StackGres namespace already exists, skipping operator installation"
        fi
        
        # Deploy Qdrant
        if ! kubectl get namespace qdrant &>/dev/null; then
          echo "Installing Qdrant vector database..."
          kubectl create namespace qdrant
          
          # Add Helm repository with retry
          for i in {1..3}; do
            if helm repo add qdrant https://qdrant.github.io/qdrant-helm; then
              break
            fi
            echo "Retry $i: Adding Qdrant Helm repo..."
            sleep 5
          done
          
          helm repo update
          
          # Only install if values file exists
          if [ -f values/qdrant-values.yaml ]; then
            helm upgrade --install qdrant qdrant/qdrant \
              --namespace qdrant \
              --create-namespace \
              --values values/qdrant-values.yaml \
              --wait --timeout 3m
          else
            echo "Warning: values/qdrant-values.yaml not found, installing with defaults"
            helm upgrade --install qdrant qdrant/qdrant \
              --namespace qdrant \
              --create-namespace \
              --wait --timeout 3m
          fi
        else
          echo "Qdrant namespace already exists, skipping installation"
        fi
        
        # Deploy NodeLocal DNS if configured
        if [ -f manifests/nodelocal-dns.yaml ]; then
          echo "Deploying NodeLocal DNS cache..."
          kubectl apply -f manifests/nodelocal-dns.yaml
        fi
    
    - name: Deploy Applications
      run: |
        echo "Deploying application manifests..."
        deployment_count=0
        
        # Function to safely deploy manifests from a directory
        deploy_directory() {
          local dir=$1
          if [ -d "$dir" ]; then
            # Find all YAML files, excluding .gitkeep
            yaml_files=$(find "$dir" \( -name "*.yaml" -o -name "*.yml" \) ! -name ".gitkeep" 2>/dev/null)
            if [ -n "$yaml_files" ]; then
              file_count=$(echo "$yaml_files" | wc -l)
              echo "Found $file_count YAML file(s) in $dir"
              
              # Apply each file individually for better error handling
              for file in $yaml_files; do
                echo "  Applying: $file"
                if kubectl apply -f "$file"; then
                  deployment_count=$((deployment_count + 1))
                else
                  echo "  Warning: Failed to apply $file"
                fi
              done
            else
              echo "No YAML files found in $dir (skipping)"
            fi
          else
            echo "Directory $dir does not exist (skipping)"
          fi
        }
        
        # Deploy from each directory
        deploy_directory "apps"
        deploy_directory "k8s"
        
        # Special handling for manifests directory to avoid re-applying nodelocal-dns
        if [ -d "manifests" ]; then
          # Deploy stackgres resources if CRDs are available
          if kubectl get crd sgclusters.stackgres.io &>/dev/null; then
            if [ -d "manifests/stackgres" ]; then
              echo "Deploying StackGres resources..."
              deploy_directory "manifests/stackgres"
            fi
          else
            echo "StackGres CRDs not found, skipping SGCluster deployment"
          fi
          
          # Deploy other manifests (excluding already processed ones)
          yaml_files=$(find manifests -maxdepth 1 \( -name "*.yaml" -o -name "*.yml" \) ! -name "nodelocal-dns.yaml" 2>/dev/null)
          if [ -n "$yaml_files" ]; then
            for file in $yaml_files; do
              echo "  Applying: $file"
              if kubectl apply -f "$file"; then
                deployment_count=$((deployment_count + 1))
              fi
            done
          fi
        fi
        
        echo "Total manifests deployed: $deployment_count"
    
    - name: Wait for Deployments
      run: |
        # Wait for all deployments to be ready
        kubectl get deployments --all-namespaces -o json | \
          jq -r '.items[] | "\(.metadata.namespace) \(.metadata.name)"' | \
          while read ns name; do
            echo "Waiting for deployment $name in namespace $ns"
            kubectl rollout status deployment/$name -n $ns --timeout=300s || true
          done
    
    - name: Health Check
      run: |
        echo "=== Cluster Status ==="
        kubectl get nodes
        echo ""
        echo "=== Pod Status ==="
        kubectl get pods --all-namespaces | grep -v Running | grep -v Completed || true
        echo ""
        echo "=== Services ==="
        kubectl get svc --all-namespaces
        echo ""
        echo "=== Ingresses ==="
        kubectl get ingress --all-namespaces